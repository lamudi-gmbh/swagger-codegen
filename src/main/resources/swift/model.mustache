
import Foundation

{{#models}}
{{#model}}
class {{classname}}: BaseModel, Deserializable {
{{#vars}}{{#description}}
    /*
     * {{{description}}}
     */{{/description}}
    {{#required}}private {{/required}}var {{#required}}__{{/required}}{{name}}:{{datatype}}?{{#required}}
    var {{name}} : {{datatype}} {
        get {
            return __{{name}}!
        }
    }{{/required}}
{{/vars}}

    required init(data: [String : AnyObject]) { 
    {{#vars}}
        {{#required}}__{{/required}}{{name}} <<<{{#complexType}}<{{/complexType}}{{#isContainer}}*{{/isContainer}} data["{{baseName}}"]{{/vars}} 

    }

    override func sanitizeAndValidate() -> (Bool, String?) { {{#hasRequiredVars}}
        var failedProps:[String] = []
        var failed = false{{/hasRequiredVars}}
        {{#vars}}{{#required}}
        if {{#required}}__{{/required}}{{name}} == nil{{#complexType}}{{^isContainer}} || {{#required}}__{{/required}}{{name}}!.sanitizeAndValidate().0 == false{{/isContainer}}{{/complexType}} {
            failed = true
            failedProps.append("'{{baseName}}'")
        }{{#complexType}}{{#isContainer}} else { 
            for obj in {{#required}}__{{/required}}{{name}}! {
                let (isValid, errMessage) = obj{{#isMap}}.1{{/isMap}}.sanitizeAndValidate()
                if !isValid {
                    failed = true
                    failedProps.append("{{#isMap}}'{{baseName}}[\(obj.0)]'{{/isMap}}{{^isMap}}a member of '{{baseName}}'{{/isMap}}(\(errMessage))")
                    break;
                }
            }
        } {{/isContainer}}{{/complexType}}
        {{/required}}{{^required}}{{#complexType}}
        {{#hasRequiredVars}}if !failed { {{/hasRequiredVars}}{{#isContainer}}
{{#hasRequiredVars}}    {{/hasRequiredVars}}        if {{#isMap}}var collection = {{name}}{{/isMap}}{{^isMap}}{{name}} != nil{{/isMap}} {
{{#hasRequiredVars}}    {{/hasRequiredVars}}            {{#isMap}}let keys = Array(collection.keys)
{{#hasRequiredVars}}    {{/hasRequiredVars}}            for key in keys {
{{#hasRequiredVars}}    {{/hasRequiredVars}}                if !collection[key]!.sanitizeAndValidate().0 {
{{#hasRequiredVars}}    {{/hasRequiredVars}}                    collection.removeValueForKey(key)
{{#hasRequiredVars}}    {{/hasRequiredVars}}                }
{{#hasRequiredVars}}    {{/hasRequiredVars}}            }{{/isMap}}{{^isMap}}{{name}} = {{name}}!.filter{$0.sanitizeAndValidate().0} {{/isMap}}
{{#hasRequiredVars}}    {{/hasRequiredVars}}            if {{name}}!.count == 0 {
{{#hasRequiredVars}}    {{/hasRequiredVars}}                {{name}} = nil
{{#hasRequiredVars}}    {{/hasRequiredVars}}            }
{{#hasRequiredVars}}    {{/hasRequiredVars}}        } {{/isContainer}}{{^isContainer}}
{{#hasRequiredVars}}    {{/hasRequiredVars}}        if {{name}} != nil && !{{name}}!.sanitizeAndValidate().0 {
{{#hasRequiredVars}}    {{/hasRequiredVars}}            {{name}} = nil
{{#hasRequiredVars}}    {{/hasRequiredVars}}        }
        {{/isContainer}}{{#hasRequiredVars}}}{{/hasRequiredVars}} {{/complexType}}{{/required}}{{/vars}}
        {{#hasRequiredVars}}if failed {
            let failedPropsString = ", ".join(failedProps)
            return (false, "{{classname}} object without (\(failedPropsString)) is not valid. Mapping failed.")
        }
        {{/hasRequiredVars}}
        
        return (true, nil)
    }
}
{{/model}}
{{/models}}